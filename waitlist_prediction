# app.R — ORSF survival Shiny app (clean rebuild)
# - Loads bundled tidymodels workflow from "orsf_workflow.rds"
# - Manual inputs only (no CSV upload)
# - Age categorical select; HLA numeric; painel_bin categorical
# - Hidden predictor transplante_bin is injected as numeric 0 by default
# - Identity flags (hla_*_identity) are derived from allele pairs
# - Outputs transplant probability (1 - S(t)) at 12/24/36/48/60 months (in %)
# - Median time-to-event shown; if not reached, displays message
# - "Sobre" tab with author info + mailto button; WhatsApp share button on main tab

options(shiny.fullstacktrace = TRUE)

# Silence reticulate noise on servers without Python
Sys.setenv(RETICULATE_PYTHON_FALLBACK = "1",
           RETICULATE_MINICONDA_ENABLED = "FALSE")

# -------------------------
# Packages & checks
# -------------------------
needed <- c(
  "shiny","tidymodels","censored","bundle","workflows","recipes",
  "parsnip","dplyr","purrr","tidyr","readr","tibble",
  "aorsf","bonsai","embed"
)
miss <- needed[!vapply(needed, requireNamespace, logical(1), quietly = TRUE)]
if (length(miss)) stop("Missing packages: ", paste(miss, collapse = ", "),
                       "\nPlease install them before running the app.")

library(shiny)
library(tidymodels)
library(censored)
library(bundle)
library(workflows)
library(recipes)
library(parsnip)
library(dplyr)
library(purrr)
library(tidyr)
library(readr)
library(tibble)
library(aorsf)
library(bonsai)
library(embed)

# -------------------------
# Config
# -------------------------
model_path  <- "orsf_workflow.rds"   # must be in the same folder as this app.R
short_times <- c(12, 24, 36, 48, 60) # months
grid_times  <- 1:120                 # months, for median estimate

if (!file.exists(model_path)) stop("File not found: ", model_path)

# -------------------------
# Load model & recipe
# -------------------------
wf  <- bundle::unbundle(readRDS(model_path))
rec <- try(workflows::extract_recipe(wf), silent = TRUE)
if (inherits(rec, "try-error") || is.null(rec)) {
  stop("This app expects a workflow with a trained recipe embedded.")
}

# Check for supervised encoding steps from {embed}
uses_lencode <- any(vapply(rec$steps, function(s) inherits(s, "step_lencode_glm"), logical(1)))
if (uses_lencode && !requireNamespace("embed", quietly = TRUE)) {
  stop("This workflow uses 'step_lencode_glm' from the 'embed' package. Please install.packages('embed') on the server.")
}

pred_info   <- rec$var_info %>% dplyr::filter(role == "predictor")
levels_list <- rec$levels

# ----- Explicit classes (front-end & coercion) -----
# Identity flags (fallback if recipe didn't store levels)
if (is.null(levels_list[["hla_DR_identity"]])) levels_list[["hla_DR_identity"]] <- c("identity","not_identity")
if (is.null(levels_list[["hla_B_identity"]]))  levels_list[["hla_B_identity"]]  <- c("identity","not_identity")

# Age EXACT levels (as provided)
levels_list[["age"]] <- c("18 to 60","under 18","more than 60")

# painel_bin categories (explicit)
levels_list[["painel_bin"]] <- c("0","1-79","80-89","90-100")

# ABO order
levels_list[["ABO_group"]] <- c("A","AB","B","O")

# underline_disease explicit classes
levels_list[["underline_disease"]] <- c("Diabetes","Glomerulonephritis","Hypertension","Indeterminate","Other")

# centro explicit classes (no accents to match common training)
levels_list[["centro"]] <- c(
  "Bahia","Belo Horizonte","Blumenau","Brasilia","Campo Grande","Cuiaba",
  "Fortaleza","Goiania","Joao Pessoa","Juiz de Fora","Maceio","Manaus",
  "Maranhao","Natal","Para","Parana","Piaui","Porto Alegre","Recife",
  "Rio de Janeiro","Roraima","Salvador","SP_Capital","SP_Interior",
  "Uberlandia","Vitoria"
)

# pt-BR binary factors
levels_list[["prior_tx"]]           <- c("Não","Sim")
levels_list[["sorologia_anti_hbs"]] <- c("Não","Sim")

# Predictor order used by the recipe (we will match this for prediction)
predictor_order <- pred_info$variable

# Hidden predictors (not shown in UI) with defaults
hidden_predictors <- c("transplante_bin", "hla_DR_identity", "hla_B_identity")
ui_predictors     <- setdiff(predictor_order, hidden_predictors)
hidden_defaults   <- list(transplante_bin = 0)

# -------------------------
# Types
# -------------------------
numeric_force <- c(
  "time_dialysis_ys",
  "hla_dr1","hla_dr2","hla_b1","hla_b2","hla_a1","hla_a2"
)

get_pred_type <- function(v){
  if (v %in% numeric_force) return("numeric")
  if (v %in% c("hla_DR_identity","hla_B_identity")) return("nominal")
  if (v == "age")          return("nominal")
  if (v == "painel_bin")   return("nominal")
  if (v == "centro")       return("nominal")
  if (v %in% c("prior_tx","sorologia_anti_hbs")) return("nominal")
  if (v == "transplante_bin") return("numeric")
  # fallback to recipe-declared type
  pred_info$type[pred_info$variable == v][1]
}

# -------------------------
# Helpers
# -------------------------
# Build one-row tibble from UI inputs
build_manual_row <- function(input){
  vals <- purrr::map(ui_predictors, function(v){
    tp <- get_pred_type(v)
    if (tp %in% c("numeric","double","integer")) {
      suppressWarnings(as.numeric(input[[v]]))
    } else {
      lv <- levels_list[[v]]
      if (!is.null(lv)) factor(input[[v]], levels = lv) else as.character(input[[v]])
    }
  })
  tibble::as_tibble(stats::setNames(vals, ui_predictors))
}

coerce_factor_columns <- function(df){
  for (v in names(df)) {
    if (get_pred_type(v) %in% c("factor","nominal","character","ordered","unordered")) {
      lv <- levels_list[[v]]
      if (!is.null(lv) && v %in% names(df)) df[[v]] <- factor(df[[v]], levels = lv)
    }
  }
  df
}

coerce_numeric_columns <- function(df){
  for (v in names(df)) {
    if (get_pred_type(v) %in% c("numeric","double","integer")) {
      df[[v]] <- suppressWarnings(as.numeric(df[[v]]))
    }
  }
  df
}

# Robust prediction wrappers and validation
safe_predict <- function(expr, context = "predict"){
  tryCatch(expr, error = function(e){
    msg <- paste0("[", context, "] ", conditionMessage(e))
    message(msg)
    shiny::validate(shiny::need(FALSE, paste("Prediction failed:", conditionMessage(e))))
  })
}

assert_newdata <- function(nd){
  # 1) Missing predictors
  missing <- setdiff(predictor_order, names(nd))
  shiny::validate(shiny::need(length(missing) == 0,
                              paste0("Missing predictors: ", paste(missing, collapse = ", "))))
  # 2) Unknown factor levels
  fact_vars <- predictor_order[vapply(
    predictor_order,
    function(v) get_pred_type(v) %in% c("factor","nominal","character","ordered","unordered"),
    logical(1)
  )]
  for (v in fact_vars) {
    lv <- levels_list[[v]]
    if (!is.null(lv) && v %in% names(nd)) {
      vals <- unique(as.character(nd[[v]]))
      bad  <- setdiff(vals[!is.na(vals)], lv)
      shiny::validate(shiny::need(length(bad) == 0,
                                  paste0("Unknown level in '", v, "': ", paste(bad, collapse = ", "))))
    }
  }
  invisible(TRUE)
}

# Example case defaults (prefilled UI)
example_case <- list(
  age = "18 to 60",
  underline_disease = "Indeterminate",
  painel_bin = "0",
  time_dialysis_ys = 1,
  ABO_group = "O",
  centro = "SP_Capital",
  prior_tx = "Não",
  sorologia_anti_hbs = "Não",
  hla_dr1 = 3,
  hla_dr2 = 4,
  hla_b1 = 7,
  hla_b2 = 15,
  hla_a1 = 2,
  hla_a2 = 24
)

# Build current app URL for sharing
build_app_url <- function(session){
  cd <- session$clientData
  proto <- ifelse(identical(cd$url_protocol, "https:"), "https://", "http://")
  host  <- cd$url_hostname
  port  <- cd$url_port
  path  <- cd$url_pathname
  query <- cd$url_search
  port_part <- if (nzchar(port) && !port %in% c("80","443")) paste0(":", port) else ""
  paste0(proto, host, port_part, path, query)
}

# -------------------------
# UI (navbar with About tab)
# -------------------------
ui <- navbarPage(
  title = "ORSF – Transplant Probability (Shiny) – with explicit classes",
  tabPanel(
    "App",
    fluidPage(
      sidebarLayout(
        sidebarPanel(
          tags$p("Provide predictors below."),
          tags$hr(),
          uiOutput("dynamic_inputs"),
          actionButton("predict_btn", "Predict", class = "btn-primary"),
          actionButton("fill_example", "Use example", class = "btn-secondary"),
          width = 4
        ),
        mainPanel(
          uiOutput("whatsapp_btn"),
          tags$br(),
          h3("Predicted transplant probability (1 - S(t))"),
          tableOutput("risk_table"),
          tags$br(),
          h3("Median time-to-event (months)"),
          tableOutput("median_table"),
          tags$br(),
          h3("Predicted transplantability curve (first row)"),
          plotOutput("surv_plot", height = 350)
        )
      )
    )
  ),
  tabPanel(
    "Sobre",
    fluidPage(
      h2("Sobre"),
      tags$p("Desenvolvido por Luis Gustavo Modelli de Andrade."),
      tags$p(
        "Email: ",
        tags$a(href = "mailto:gustavo.modelli@unesp.br", "gustavo.modelli@unesp.br")
      ),
      tags$a(
        "Enviar email",
        href = "mailto:gustavo.modelli@unesp.br",
        class = "btn btn-primary",
        target = "_blank"
      )
    )
  )
)

# -------------------------
# Server
# -------------------------
server <- function(input, output, session){
  
  # Dynamic inputs
  output$dynamic_inputs <- renderUI({
    tagList(
      lapply(ui_predictors, function(v){
        tp <- get_pred_type(v)
        if (tp %in% c("numeric","double","integer")) {
          numericInput(v, label = v,
                       value = if (!is.null(example_case[[v]])) suppressWarnings(as.numeric(example_case[[v]])) else NA_real_)
        } else {
          lv <- levels_list[[v]]
          if (!is.null(lv)) {
            sel <- if (!is.null(example_case[[v]]) && example_case[[v]] %in% lv) example_case[[v]] else lv[1]
            selectInput(v, label = v, choices = lv, selected = sel)
          } else {
            textInput(v, label = paste0(v, " (text)"),
                      value = if (!is.null(example_case[[v]])) as.character(example_case[[v]]) else "")
          }
        }
      })
    )
  })
  
  # WhatsApp share button
  output$whatsapp_btn <- renderUI({
    url <- build_app_url(session)
    txt <- utils::URLencode(paste0("Confira este app de predição de transplante: ", url), reserved = TRUE)
    href <- paste0("https://wa.me/?text=", txt)
    tags$a("Share to WhatsApp", href = href, target = "_blank", class = "btn btn-success")
  })
  
  # Fill with example defaults (inputs já vêm preenchidos; este botão funciona como reset)
  observeEvent(input$fill_example, {
    lapply(ui_predictors, function(v){
      tp  <- get_pred_type(v)
      val <- example_case[[v]]
      if (is.null(val)) return(NULL)
      if (tp %in% c("numeric","double","integer")) {
        shiny::updateNumericInput(session, v, value = suppressWarnings(as.numeric(val)))
      } else {
        lv <- levels_list[[v]]
        if (!is.null(lv)) {
          sel <- if (!is.null(val) && val %in% lv) val else lv[1]
          shiny::updateSelectInput(session, v, selected = sel)
        } else {
          shiny::updateTextInput(session, v, value = as.character(val))
        }
      }
    })
  })
  
  input_data <- eventReactive(input$predict_btn, {
    df <- build_manual_row(input)
    df <- coerce_numeric_columns(df)
    
    # Deriva identidades (ocultas na UI) a partir dos pares
    df <- df %>%
      dplyr::mutate(
        hla_DR_identity = dplyr::case_when(
          !is.na(hla_dr1) & !is.na(hla_dr2) & hla_dr1 == hla_dr2 ~ "identity",
          TRUE ~ "not_identity"
        ),
        hla_B_identity = dplyr::case_when(
          !is.na(hla_b1) & !is.na(hla_b2) & hla_b1 == hla_b2 ~ "identity",
          TRUE ~ "not_identity"
        )
      )
    
    # Coerção de fatores após calcular identidades
    df <- coerce_factor_columns(df)
    
    # ---- PREENCHER PREDITORES FALTANTES ANTES DE REORDENAR ----
    missing <- setdiff(predictor_order, names(df))
    if (length(missing)) {
      for (mn in missing) {
        tp <- get_pred_type(mn)
        if (tp %in% c("numeric","double","integer")) {
          df[[mn]] <- NA_real_
        } else {
          lv <- levels_list[[mn]]
          if (is.null(lv)) {
            df[[mn]] <- NA_character_
          } else {
            df[[mn]] <- factor(NA_character_, levels = lv)
          }
        }
      }
    }
    
    # Reordena exatamente conforme o recipe (agora seguro)
    df <- df[, predictor_order, drop = FALSE]
    
    df
  }, ignoreInit = TRUE)
  
  # Predictions
  preds <- reactive({
    req(input_data())
    nd <- input_data()
    
    # Validate newdata before predict
    assert_newdata(nd)
    
    # Survival predictions (safe)
    surv_short <- safe_predict(
      predict(wf, new_data = nd, type = "survival", eval_time = short_times),
      context = "surv_short"
    )
    surv_grid  <- safe_predict(
      predict(wf, new_data = nd, type = "survival", eval_time = grid_times),
      context = "surv_grid"
    )
    
    # Short-time risks in %
    surv_wide <- purrr::map_dfr(
      surv_short$.pred,
      ~{
        dfi <- .x
        dfi <- dfi[match(short_times, dfi$.eval_time), , drop = FALSE]
        tibble::as_tibble_row(stats::setNames(as.list(dfi$.pred_survival), paste0("S_", short_times)))
      }
    )
    
    risk_wide <- surv_wide
    risk_cols <- paste0("S_", short_times)
    risk_wide[risk_cols] <- lapply(risk_wide[risk_cols], function(x) (1 - x) * 100)
    names(risk_wide) <- paste0("Tx at ", short_times, " mo")
    risk_wide <- dplyr::mutate(risk_wide, dplyr::across(dplyr::everything(), ~ sprintf("%.1f%%", .)))
    
    # Median time: first grid time where S(t) <= 0.5
    median_vec <- purrr::map_dbl(surv_grid$.pred, function(dfm){
      idx <- which(dfm$.pred_survival <= 0.5)[1]
      if (!is.na(idx)) dfm$.eval_time[idx] else NA_real_
    })
    
    list(risk = risk_wide, median = median_vec, surv_grid = surv_grid)
  })
  
  output$risk_table <- renderTable({
    req(preds())
    preds()$risk
  }, digits = 3)
  
  output$median_table <- renderTable({
    req(preds())
    med <- preds()$median
    label <- ifelse(is.na(med[1]),
                    paste0("Not reached by ", max(grid_times), " mo"),
                    sprintf("%.1f", med[1]))
    tibble::tibble(`Median time (mo)` = label)
  })
  
  # Predicted transplantability curve (first valid row)
  output$surv_plot <- renderPlot({
    req(preds())
    sg <- preds()$surv_grid
    
    good_idx <- which(purrr::map_lgl(sg$.pred, ~ is.data.frame(.x) && nrow(.x) > 0))[1]
    validate(need(length(good_idx) == 1, "No curve available to plot."))
    
    dfc <- sg$.pred[[good_idx]]
    validate(need(all(c(".eval_time",".pred_survival") %in% names(dfc)),
                  "Prediction object missing required columns."))
    
    x <- suppressWarnings(as.numeric(dfc$.eval_time))
    y <- suppressWarnings(as.numeric(dfc$.pred_survival))
    validate(need(length(x) == length(y) && length(x) > 0, "Invalid curve length."))
    validate(need(all(is.finite(x)) && all(is.finite(y)), "Curve contains non-finite values."))
    
    y_tx <- (1 - y) * 100
    plot(x, y_tx, type = "l",
         xlab = "Time (months)", ylab = "Tx probability (1 - S(t)) [%]",
         main = "Predicted transplantability (first row)", ylim = c(0, 100))
    abline(h = 50, lty = 2)
  }, res = 96)
}

shinyApp(ui, server)
