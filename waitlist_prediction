# app.R — ORSF survival Shiny app (with About tab & WhatsApp share)
# - Loads bundled tidymodels workflow from "orsf_workflow.rds"
# - Manual inputs only (no CSV upload)
# - Age categorical select; HLA numeric; painel_bin categorical
# - Hidden predictor transplante_bin is injected as numeric 0 by default
# - Outputs transplant probability (1 - S(t)) at 12/24/36/48/60 months (in %)
# - Estimates median time-to-event (or shows "Not reached by ... mo")
# - NEW: "Sobre" tab with author info and email button; WhatsApp share button on main tab

options(shiny.fullstacktrace = TRUE)

# -------------------------
# Packages & checks
# -------------------------
needed <- c("shiny","tidymodels","censored","bundle","workflows","recipes",
            "parsnip","dplyr","purrr","tidyr","readr","tibble","aorsf","bonsai","embed")
miss <- needed[!vapply(needed, requireNamespace, logical(1), quietly = TRUE)]
if (length(miss)) stop("Missing packages: ", paste(miss, collapse = ", "),
                       "
Please install them before running the app.")

library(shiny)
library(tidymodels)
library(censored)
library(bundle)
library(workflows)
library(recipes)
library(parsnip)
library(dplyr)
library(purrr)
library(tidyr)
library(readr)
library(tibble)
library(aorsf)
library(bonsai)
library(embed)

# -------------------------
# Config
# -------------------------
model_path  <- "orsf_workflow.rds"         # must be in the same folder as this app.R
short_times <- c(12, 24, 36, 48, 60)        # months
grid_times  <- 1:120                        # months, for median estimate

# Optional: silence reticulate warnings on servers without Python
Sys.setenv(RETICULATE_PYTHON_FALLBACK = "1", RETICULATE_MINICONDA_ENABLED = "FALSE")

if (!file.exists(model_path)) stop("File not found: ", model_path)

# -------------------------
# Load model & recipe
# -------------------------
wf <- bundle::unbundle(readRDS(model_path))
rec <- try(workflows::extract_recipe(wf), silent = TRUE)
if (inherits(rec, "try-error") || is.null(rec)) {
  stop("This app expects a workflow with a trained recipe embedded.")
}

# Fail fast if recipe uses encoding steps from 'embed' and the pkg isn't available
uses_lencode <- any(vapply(rec$steps, function(s) inherits(s, "step_lencode_glm"), logical(1)))
if (uses_lencode && !requireNamespace("embed", quietly = TRUE)) {
  stop("This workflow uses 'step_lencode_glm' from the 'embed' package. Please install.packages('embed') on the server.")
}

pred_info   <- rec$var_info %>% dplyr::filter(role == "predictor")
levels_list <- rec$levels

# ----- Explicit classes (front-end & for coercion) -----
# Identity flags (fallback if recipe didn't store levels)
if (is.null(levels_list[["hla_DR_identity"]])) levels_list[["hla_DR_identity"]] <- c("identity","not_identity")
if (is.null(levels_list[["hla_B_identity"]]))  levels_list[["hla_B_identity"]]  <- c("identity","not_identity")

# Age EXACT levels (as provided)
levels_list[["age"]] <- c("18 to 60","under 18","more than 60")

# painel_bin categories
levels_list[["painel_bin"]] <- c("0","1-79","80-89","90-100")

# ABO order
levels_list[["ABO_group"]] <- c("A","AB","B","O")

# underline_disease explicit classes
levels_list[["underline_disease"]] <- c("Diabetes","Glomerulonephritis","Hypertension","Indeterminate","Other")

# centro explicit classes (without accents to match most training schemas)
levels_list[["centro"]] <- c(
  "Bahia","Belo Horizonte","Blumenau","Brasilia","Campo Grande","Cuiaba",
  "Fortaleza","Goiania","Joao Pessoa","Juiz de Fora","Maceio","Manaus",
  "Maranhao","Natal","Para","Parana","Piaui","Porto Alegre","Recife",
  "Rio de Janeiro","Roraima","Salvador","SP_Capital","SP_Interior",
  "Uberlandia","Vitoria"
)

# pt-BR binary factors
levels_list[["prior_tx"]] <- c("Não","Sim")
levels_list[["sorologia_anti_hbs"]] <- c("Não","Sim")

# Predictor order used by the recipe (we will match this for prediction)
predictor_order <- pred_info$variable

# Hide from UI but inject defaults into prediction data
hidden_predictors <- c("transplante_bin", "hla_DR_identity", "hla_B_identity")
ui_predictors     <- setdiff(predictor_order, hidden_predictors)
hidden_defaults   <- list(transplante_bin = 0)

# -------------------------
# Type overrides (requested): Age categorical; identity flags categorical; HLA numeric; painel_bin categorical
# -------------------------
numeric_force <- c(
  "time_dialysis_ys",
  "hla_dr1","hla_dr2","hla_b1","hla_b2","hla_a1","hla_a2"
)

get_pred_type <- function(v){
  if (v %in% numeric_force) return("numeric")
  if (v %in% c("hla_DR_identity","hla_B_identity")) return("nominal")
  if (v == "age")          return("nominal")
  if (v == "painel_bin")   return("nominal")
  if (v == "centro")       return("nominal")
  if (v %in% c("prior_tx","sorologia_anti_hbs")) return("nominal")
  if (v == "transplante_bin") return("numeric")
  # fallback to recipe-declared type
  pred_info$type[pred_info$variable == v][1]
}

# -------------------------
# Helpers
# -------------------------
# Build a one-row tibble from UI inputs, casting by desired type
build_manual_row <- function(input){
  vals <- purrr::map(ui_predictors, function(v){
    tp <- get_pred_type(v)
    if (tp %in% c("numeric","double","integer")) {
      suppressWarnings(as.numeric(input[[v]]))
    } else {
      lv <- levels_list[[v]]
      if (!is.null(lv)) factor(input[[v]], levels = lv) else as.character(input[[v]])
    }
  })
  tibble::as_tibble(stats::setNames(vals, ui_predictors))
}

coerce_factor_columns <- function(df){
  for (v in names(df)) {
    if (get_pred_type(v) %in% c("factor","nominal","character","ordered","unordered")) {
      lv <- levels_list[[v]]
      if (!is.null(lv) && v %in% names(df)) df[[v]] <- factor(df[[v]], levels = lv)
    }
  }
  df
}

coerce_numeric_columns <- function(df){
  for (v in names(df)) {
    if (get_pred_type(v) %in% c("numeric","double","integer")) {
      df[[v]] <- suppressWarnings(as.numeric(df[[v]]))
    }
  }
  df
}

# Example case defaults (for quick testing)
example_case <- list(
  age = '18 to 60',
  underline_disease = 'Indeterminate',
  painel_bin = '0',
  time_dialysis_ys = 1,
  ABO_group = 'O',
  centro = 'SP_Capital',
  prior_tx = 'Não',
  hla_DR_identity = 'not_identity',
  hla_B_identity = 'not_identity',
  sorologia_anti_hbs = 'Não',
  hla_dr1 = 3,
  hla_dr2 = 4,
  hla_b1 = 7,
  hla_b2 = 15,
  hla_a1 = 2,
  hla_a2 = 24
)

# Build current app URL for sharing
build_app_url <- function(session){
  cd <- session$clientData
  proto <- ifelse(identical(cd$url_protocol, "https:"), "https://", "http://")
  host  <- cd$url_hostname
  port  <- cd$url_port
  path  <- cd$url_pathname
  query <- cd$url_search
  port_part <- if (nzchar(port) && !port %in% c("80","443")) paste0(":", port) else ""
  paste0(proto, host, port_part, path, query)
}

# -------------------------
# UI (navbar with About tab)
# -------------------------
ui <- navbarPage(
  title = "ORSF – Transplant Probability (Shiny) – with explicit classes",
  tabPanel(
    "App",
    fluidPage(
      sidebarLayout(
        sidebarPanel(
          tags$p("Provide predictors below."),
          tags$hr(),
          uiOutput("dynamic_inputs"),
          actionButton("predict_btn", "Predict", class = "btn-primary"),
          actionButton("fill_example", "Use example", class = "btn-secondary"),
          width = 4
        ),
        mainPanel(
          uiOutput("whatsapp_btn"),
          tags$br(),
          h3("Predicted transplant probability (1 - S(t))"),
          tableOutput("risk_table"),
          tags$br(),
          h3("Median time-to-event (months)"),
          tableOutput("median_table"),
          tags$br(),
          h3("Predicted transplantability curve (first row)"),
          plotOutput("surv_plot", height = 350)
        )
      )
    )
  ),
  tabPanel(
    "Sobre",
    fluidPage(
      h2("Sobre"),
      tags$p("Desenvolvido por Luis Gustavo Modelli de Andrade."),
      tags$p(
        "Email: ",
        tags$a(href = "mailto:gustavo.modelli@unesp.br", "gustavo.modelli@unesp.br")
      ),
      tags$a(
        "Enviar email",
        href = "mailto:gustavo.modelli@unesp.br",
        class = "btn btn-primary",
        target = "_blank"
      )
    )
  )
)

# -------------------------
# Server
# -------------------------
server <- function(input, output, session){
  
  # Dynamic inputs built from recipe + overrides
  output$dynamic_inputs <- renderUI({
    tagList(
      lapply(ui_predictors, function(v){
        tp <- get_pred_type(v)
        if (tp %in% c("numeric","double","integer")) {
          numericInput(v, label = v,
                       value = if (!is.null(example_case[[v]])) suppressWarnings(as.numeric(example_case[[v]])) else NA_real_)
        } else {
          lv <- levels_list[[v]]
          if (!is.null(lv)) {
            sel <- if (!is.null(example_case[[v]]) && example_case[[v]] %in% lv) example_case[[v]] else lv[1]
            selectInput(v, label = v, choices = lv, selected = sel)
          } else {
            textInput(v, label = paste0(v, " (text)"),
                      value = if (!is.null(example_case[[v]])) as.character(example_case[[v]]) else "")
          }
        }
      })
    )
  })
  
  # WhatsApp share button (computed from current app URL)
  output$whatsapp_btn <- renderUI({
    url <- build_app_url(session)
    txt <- utils::URLencode(paste0("Confira este app de predição de transplante: ", url), reserved = TRUE)
    href <- paste0("https://wa.me/?text=", txt)
    tags$a("Share to WhatsApp", href = href, target = "_blank", class = "btn btn-success")
  })
  
  # Fill with example defaults (on click — inputs already prefilled above)
  observeEvent(input$fill_example, {
    lapply(ui_predictors, function(v){
      tp  <- get_pred_type(v)
      val <- example_case[[v]]
      if (is.null(val)) return(NULL)
      if (tp %in% c("numeric","double","integer")) {
        shiny::updateNumericInput(session, v, value = suppressWarnings(as.numeric(val)))
      } else {
        lv <- levels_list[[v]]
        if (!is.null(lv)) {
          sel <- if (!is.null(val) && val %in% lv) val else lv[1]
          shiny::updateSelectInput(session, v, selected = sel)
        } else {
          shiny::updateTextInput(session, v, value = as.character(val))
        }
      }
    })
  })
  
  # Build input row (manual only)
  input_data <- eventReactive(input$predict_btn, {
    df <- build_manual_row(input)
    df <- coerce_numeric_columns(df)
    
    # --- Compute identity flags from allele pairs (hidden in UI) ---
    df <- df %>% dplyr::mutate(
      hla_DR_identity = dplyr::case_when(
        !is.na(hla_dr1) & !is.na(hla_dr2) & hla_dr1 == hla_dr2 ~ "identity",
        TRUE ~ "not_identity"
      ),
      hla_B_identity = dplyr::case_when(
        !is.na(hla_b1) & !is.na(hla_b2) & hla_b1 == hla_b2 ~ "identity",
        TRUE ~ "not_identity"
      )
    )
    
    # Coerce factors (apply levels after computing identities)
    df <- coerce_factor_columns(df)
    
    # Add hidden predictors with defaults and correct type
    need_hidden <- intersect(hidden_predictors, predictor_order)
    for (hn in need_hidden) {
      if (!hn %in% names(df)) {
        tp  <- get_pred_type(hn)
        val <- hidden_defaults[[hn]]
        if (is.null(val)) val <- NA
        if (tp %in% c("numeric","double","integer")) {
          df[[hn]] <- suppressWarnings(as.numeric(val))
        } else {
          lv <- levels_list[[hn]]
          if (!is.null(lv)) df[[hn]] <- factor(val, levels = lv) else df[[hn]] <- as.character(val)
        }
      }
    }
    
    # Reorder columns to exactly match the recipe predictors
    df <- df[, predictor_order, drop = FALSE]
    df
  }, ignoreInit = TRUE)
  
  # Predictions
  preds <- reactive({
    req(input_data())
    nd <- input_data()
    
    # Survival predictions at requested times and grid
    surv_short <- predict(wf, new_data = nd, type = "survival", eval_time = short_times)
    surv_grid  <- predict(wf, new_data = nd, type = "survival", eval_time = grid_times)
    
    # Wide risks for short_times -> formatted as percentages without .row
    surv_wide <- purrr::map_dfr(
      surv_short$.pred,
      ~{
        df <- .x
        df <- df[match(short_times, df$.eval_time), , drop = FALSE]
        tibble::as_tibble_row(stats::setNames(as.list(df$.pred_survival), paste0("S_", short_times)))
      }
    )
    
    # Convert to transplant probability = (1 - S(t)) * 100 and label nicely
    risk_wide <- surv_wide
    risk_cols <- paste0("S_", short_times)
    risk_wide[risk_cols] <- lapply(risk_wide[risk_cols], function(x) (1 - x) * 100)
    names(risk_wide) <- paste0("Tx at ", short_times, " mo")
    risk_wide <- dplyr::mutate(risk_wide, dplyr::across(dplyr::everything(), ~ sprintf("%.1f%%", .)))
    
    # Median time: first time grid where S(t) <= 0.5
    median_vec <- purrr::map_dbl(surv_grid$.pred, function(df){
      idx <- which(df$.pred_survival <= 0.5)[1]
      if (!is.na(idx)) df$.eval_time[idx] else NA_real_
    })
    
    list(risk = risk_wide, median = median_vec, surv_grid = surv_grid)
  })
  
  output$risk_table <- renderTable({
    req(preds())
    preds()$risk
  }, digits = 3)
  
  output$median_table <- renderTable({
    req(preds())
    med <- preds()$median
    label <- ifelse(is.na(med[1]),
                    paste0("Not reached by ", max(grid_times), " mo"),
                    sprintf("%.1f", med[1]))
    tibble::tibble(`Median time (mo)` = label)
  }, sanitize.text.function = function(x) x)
  
  # --- Predicted transplantability curve (first row) ---
  output$surv_plot <- renderPlot({
    req(preds())
    sg <- preds()$surv_grid
    
    # Find first non-empty curve
    good_idx <- which(purrr::map_lgl(sg$.pred, ~ is.data.frame(.x) && nrow(.x) > 0))[1]
    validate(need(length(good_idx) == 1, "No curve available to plot."))
    
    df <- sg$.pred[[good_idx]]
    validate(need(all(c(".eval_time",".pred_survival") %in% names(df)),
                  "Prediction object missing required columns."))
    
    x <- suppressWarnings(as.numeric(df$.eval_time))
    y <- suppressWarnings(as.numeric(df$.pred_survival))
    validate(need(length(x) == length(y) && length(x) > 0, "Invalid curve length."))
    validate(need(all(is.finite(x)) && all(is.finite(y)), "Curve contains non-finite values."))
    
    y_tx <- (1 - y) * 100
    plot(x, y_tx, type = "l",
         xlab = "Time (months)", ylab = "Tx probability (1 - S(t)) [%]",
         main = "Predicted transplantability (first row)", ylim = c(0, 100))
    abline(h = 50, lty = 2)
  }, res = 96)
}

shinyApp(ui, server)

