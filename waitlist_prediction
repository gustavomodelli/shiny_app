# app.R — Cox (glmnet) survival Shiny app (clean)
# - Loads bundled tidymodels workflow from "cox_reg_workflow.rds"
# - Manual inputs only
# - Age categorical; HLA numeric; painel_bin categorical
# - Hidden predictor transplante_bin injected as 0 if the recipe expects it
# - HLA identity flags derived from allele pairs
# - Outputs: Tx = (1 - S(t)) at 12/24/36/48/60 (in %) + median time (or "Not reached")
# - "Sobre" tab + WhatsApp share button

options(shiny.fullstacktrace = TRUE)

# Silence reticulate noise on servers without Python
Sys.setenv(
  RETICULATE_PYTHON_FALLBACK = "1",
  RETICULATE_MINICONDA_ENABLED = "FALSE"
)

# -------------------------
# Packages & checks
# -------------------------
needed <- c(
  "shiny","tidymodels","censored","bundle","workflows","recipes",
  "parsnip","dplyr","purrr","tidyr","readr","tibble","glmnet","survival"
)
miss <- needed[!vapply(needed, requireNamespace, logical(1), quietly = TRUE)]
if (length(miss)) stop("Missing packages: ", paste(miss, collapse = ", "),
                       "\nPlease install them before running the app.")

library(shiny)
library(tidymodels)
library(censored)
library(bundle)
library(workflows)
library(recipes)
library(parsnip)
library(dplyr)
library(purrr)
library(tidyr)
library(readr)
library(tibble)
library(glmnet)
library(survival)

# -------------------------
# Config
# -------------------------
model_path  <- "cox_reg_workflow.rds"     # <— Cox penalizado
short_times <- c(12, 24, 36, 48, 60)      # months
grid_times  <- 1:120                      # months for median

if (!file.exists(model_path)) stop("File not found: ", model_path)

# -------------------------
# Load model & recipe
# -------------------------
wf  <- bundle::unbundle(readRDS(model_path))
rec <- try(workflows::extract_recipe(wf), silent = TRUE)
if (inherits(rec, "try-error") || is.null(rec)) {
  stop("This app expects a workflow with a trained recipe embedded.")
}

# If the recipe used supervised encoding (embed::step_lencode_glm), ensure embed is available
uses_lencode <- any(vapply(rec$steps, function(s) inherits(s, "step_lencode_glm"), logical(1)))
if (uses_lencode && !requireNamespace("embed", quietly = TRUE)) {
  stop("This workflow uses 'step_lencode_glm' from {embed}. Please install.packages('embed') on the server.")
}

pred_info   <- rec$var_info %>% dplyr::filter(role == "predictor")
levels_list <- rec$levels
if (is.null(levels_list)) levels_list <- list()  # fallback

# ----- Explicit classes (front-end & coercion) -----
# Identity flags (ensure levels exist)
if (is.null(levels_list[["hla_DR_identity"]])) levels_list[["hla_DR_identity"]] <- c("identity","not_identity")
if (is.null(levels_list[["hla_B_identity"]]))  levels_list[["hla_B_identity"]]  <- c("identity","not_identity")

# Age — exact levels
levels_list[["age"]] <- c("18 to 60","under 18","more than 60")

# painel_bin
levels_list[["painel_bin"]] <- c("0","1-79","80-89","90-100")

# ABO
levels_list[["ABO_group"]] <- c("A","AB","B","O")

# underline_disease
levels_list[["underline_disease"]] <- c("Diabetes","Glomerulonephritis","Hypertension","Indeterminate","Other")

# centro (sem acentos p/ casar com treino)
levels_list[["centro"]] <- c(
  "Bahia","Belo Horizonte","Blumenau","Brasilia","Campo Grande","Cuiaba",
  "Fortaleza","Goiania","Joao Pessoa","Juiz de Fora","Maceio","Manaus",
  "Maranhao","Natal","Para","Parana","Piaui","Porto Alegre","Recife",
  "Rio de Janeiro","Roraima","Salvador","SP_Capital","SP_Interior",
  "Uberlandia","Vitoria"
)

# pt-BR binários (usar Unicode para robustez em Linux)
levels_list[["prior_tx"]]           <- c("N\u00E3o","Sim")
levels_list[["sorologia_anti_hbs"]] <- c("N\u00E3o","Sim")

# Predictor order used by the recipe
predictor_order <- pred_info$variable

# Hidden predictors (not shown in UI) with defaults
hidden_predictors <- c("transplante_bin", "hla_DR_identity", "hla_B_identity")
ui_predictors     <- setdiff(predictor_order, hidden_predictors)
hidden_defaults   <- list(transplante_bin = 0)

# -------------------------
# Types
# -------------------------
numeric_force <- c("time_dialysis_ys","hla_dr1","hla_dr2","hla_b1","hla_b2","hla_a1","hla_a2")

get_pred_type <- function(v){
  if (v %in% numeric_force) return("numeric")
  if (v %in% c("hla_DR_identity","hla_B_identity")) return("nominal")
  if (v %in% c("age","painel_bin","centro","prior_tx","sorologia_anti_hbs")) return("nominal")
  if (v == "transplante_bin") return("numeric")
  # fallback to recipe-declared type
  pred_info$type[pred_info$variable == v][1]
}

# -------------------------
# Helpers
# -------------------------
build_manual_row <- function(input){
  vals <- purrr::map(ui_predictors, function(v){
    tp <- get_pred_type(v)
    if (tp %in% c("numeric","double","integer")) {
      suppressWarnings(as.numeric(input[[v]]))
    } else {
      lv <- levels_list[[v]]
      if (!is.null(lv)) factor(input[[v]], levels = lv) else as.character(input[[v]])
    }
  })
  tibble::as_tibble(stats::setNames(vals, ui_predictors))
}

coerce_factor_columns <- function(df){
  for (v in names(df)) {
    if (get_pred_type(v) %in% c("factor","nominal","character","ordered","unordered")) {
      lv <- levels_list[[v]]
      if (!is.null(lv)) df[[v]] <- factor(df[[v]], levels = lv)
    }
  }
  df
}

coerce_numeric_columns <- function(df){
  for (v in names(df)) {
    if (get_pred_type(v) %in% c("numeric","double","integer")) {
      df[[v]] <- suppressWarnings(as.numeric(df[[v]]))
    }
  }
  df
}

safe_predict <- function(expr, context = "predict"){
  tryCatch(expr, error = function(e){
    message("[", context, "] ", conditionMessage(e))
    validate(need(FALSE, paste("Prediction failed:", conditionMessage(e))))
  })
}

assert_newdata <- function(nd){
  # Missing predictors
  miss <- setdiff(predictor_order, names(nd))
  validate(need(length(miss) == 0,
                paste0("Missing predictors: ", paste(miss, collapse = ", "))))
  # Unknown factor levels
  fact_vars <- predictor_order[vapply(
    predictor_order,
    function(v) get_pred_type(v) %in% c("factor","nominal","character","ordered","unordered"),
    logical(1)
  )]
  for (v in fact_vars) {
    lv <- levels_list[[v]]
    if (!is.null(lv) && v %in% names(nd)) {
      vals <- unique(as.character(nd[[v]]))
      bad  <- setdiff(vals[!is.na(vals)], lv)
      validate(need(length(bad) == 0,
                    paste0("Unknown level in '", v, "': ", paste(bad, collapse = ", "))))
    }
  }
  invisible(TRUE)
}

# Example case (prefill)
example_case <- list(
  age = "18 to 60",
  underline_disease = "Indeterminate",
  painel_bin = "0",
  time_dialysis_ys = 1,
  ABO_group = "O",
  centro = "SP_Capital",
  prior_tx = "N\u00E3o",
  sorologia_anti_hbs = "N\u00E3o",
  hla_dr1 = 3, hla_dr2 = 4,
  hla_b1 = 7, hla_b2 = 15,
  hla_a1 = 2, hla_a2 = 24
)

build_app_url <- function(session){
  cd <- session$clientData
  proto <- ifelse(identical(cd$url_protocol, "https:"), "https://", "http://")
  host  <- cd$url_hostname; port <- cd$url_port
  path  <- cd$url_pathname;  query <- cd$url_search
  port_part <- if (nzchar(port) && !port %in% c("80","443")) paste0(":", port) else ""
  paste0(proto, host, port_part, path, query)
}

# -------------------------
# UI
# -------------------------
ui <- navbarPage(
  title = "Transplant Probability - Brazil",
  tabPanel(
    "App",
    fluidPage(
      sidebarLayout(
        sidebarPanel(
          tags$p("Provide predictors below."),
          tags$hr(),
          uiOutput("dynamic_inputs"),
          actionButton("predict_btn", "Predict", class = "btn-primary"),
          actionButton("fill_example", "Use example", class = "btn-secondary"),
          width = 4
        ),
        mainPanel(
          uiOutput("whatsapp_btn"),
          tags$br(),
          h3("Predicted transplant probability"),
          tableOutput("risk_table"),
          tags$br(),
          h3("Median time-to-event (months)"),
          tableOutput("median_table"),
          tags$br(),
          h3("Predicted transplantability curve"),
          plotOutput("surv_plot", height = 350)
        )
      )
    )
  ),
  tabPanel(
    "Sobre",
    fluidPage(
      h2("Sobre"),
      tags$p("Desenvolvido por Luis Gustavo Modelli de Andrade."),
      tags$p("Email: ",
             tags$a(href = "mailto:gustavo.modelli@unesp.br", "gustavo.modelli@unesp.br")),
      tags$a("Enviar email", href = "mailto:gustavo.modelli@unesp.br",
             class = "btn btn-primary", target = "_blank")
    )
  )
)

# -------------------------
# Server
# -------------------------
server <- function(input, output, session){
  
  # Dynamic inputs
  output$dynamic_inputs <- renderUI({
    tagList(lapply(ui_predictors, function(v){
      tp <- get_pred_type(v)
      if (tp %in% c("numeric","double","integer")) {
        numericInput(v, label = v,
                     value = if (!is.null(example_case[[v]])) suppressWarnings(as.numeric(example_case[[v]])) else NA_real_)
      } else {
        lv <- levels_list[[v]]
        if (!is.null(lv)) {
          sel <- if (!is.null(example_case[[v]]) && example_case[[v]] %in% lv) example_case[[v]] else lv[1]
          selectInput(v, label = v, choices = lv, selected = sel)
        } else {
          textInput(v, label = paste0(v, " (text)"),
                    value = if (!is.null(example_case[[v]])) as.character(example_case[[v]]) else "")
        }
      }
    }))
  })
  
  # WhatsApp share button
  output$whatsapp_btn <- renderUI({
    url <- build_app_url(session)
    txt <- utils::URLencode(paste0("Confira este app de predição de transplante: ", url), reserved = TRUE)
    href <- paste0("https://wa.me/?text=", txt)
    tags$a("Share to WhatsApp", href = href, target = "_blank", class = "btn btn-success")
  })
  
  # Fill example/reset
  observeEvent(input$fill_example, {
    lapply(ui_predictors, function(v){
      tp  <- get_pred_type(v); val <- example_case[[v]]
      if (is.null(val)) return(NULL)
      if (tp %in% c("numeric","double","integer")) {
        updateNumericInput(session, v, value = suppressWarnings(as.numeric(val)))
      } else {
        lv <- levels_list[[v]]
        if (!is.null(lv)) {
          sel <- if (!is.null(val) && val %in% lv) val else lv[1]
          updateSelectInput(session, v, selected = sel)
        } else {
          updateTextInput(session, v, value = as.character(val))
        }
      }
    })
  })
  
  # Build new_data robustly
  input_data <- eventReactive(input$predict_btn, {
    df <- build_manual_row(input)
    df <- coerce_numeric_columns(df)
    
    # Derive HLA identities (hidden)
    df <- df %>%
      mutate(
        hla_DR_identity = case_when(
          !is.na(hla_dr1) & !is.na(hla_dr2) & hla_dr1 == hla_dr2 ~ "identity",
          TRUE ~ "not_identity"
        ),
        hla_B_identity = case_when(
          !is.na(hla_b1) & !is.na(hla_b2) & hla_b1 == hla_b2 ~ "identity",
          TRUE ~ "not_identity"
        )
      )
    
    # Coerce factors after identities
    df <- coerce_factor_columns(df)
    
    # Inject hidden predictors only if expected by recipe
    need_hidden <- intersect(hidden_predictors, predictor_order)
    for (hn in need_hidden) {
      if (!hn %in% names(df)) {
        tp  <- get_pred_type(hn)
        val <- hidden_defaults[[hn]]
        if (is.null(val)) val <- NA
        if (tp %in% c("numeric","double","integer")) {
          df[[hn]] <- suppressWarnings(as.numeric(val))
        } else {
          lv <- levels_list[[hn]]
          if (!is.null(lv)) df[[hn]] <- factor(val, levels = lv) else df[[hn]] <- as.character(val)
        }
      }
    }
    
    # Fill any remaining predictors (type-aware) before reordering
    missing <- setdiff(predictor_order, names(df))
    if (length(missing)) {
      for (mn in missing) {
        tp <- get_pred_type(mn)
        if (tp %in% c("numeric","double","integer")) {
          df[[mn]] <- NA_real_
        } else {
          lv <- levels_list[[mn]]
          if (is.null(lv)) df[[mn]] <- factor(NA_character_) else df[[mn]] <- factor(NA_character_, levels = lv)
        }
      }
    }
    
    # Match recipe order
    df <- df[, predictor_order, drop = FALSE]
    df
  }, ignoreInit = TRUE)
  
  # Predictions
  preds <- reactive({
    req(input_data())
    nd <- input_data()
    
    # Validate newdata before predict
    assert_newdata(nd)
    
    # Survival predictions
    surv_short <- safe_predict(
      predict(wf, new_data = nd, type = "survival", eval_time = short_times),
      context = "surv_short"
    )
    surv_grid  <- safe_predict(
      predict(wf, new_data = nd, type = "survival", eval_time = grid_times),
      context = "surv_grid"
    )
    
    # Build risk table (%)
    surv_wide <- purrr::map_dfr(
      surv_short$.pred,
      ~{
        dfi <- .x
        dfi <- dfi[match(short_times, dfi$.eval_time), , drop = FALSE]
        tibble::as_tibble_row(stats::setNames(as.list(dfi$.pred_survival), paste0("S_", short_times)))
      }
    )
    
    risk_wide <- surv_wide
    risk_cols <- paste0("S_", short_times)
    risk_wide[risk_cols] <- lapply(risk_wide[risk_cols], function(x) (1 - x) * 100)
    names(risk_wide) <- paste0("Tx at ", short_times, " mo")
    risk_wide <- dplyr::mutate(risk_wide, dplyr::across(dplyr::everything(), ~ sprintf("%.1f%%", .)))
    
    # Median time: first t where S(t) <= 0.5
    median_vec <- purrr::map_dbl(surv_grid$.pred, function(dfm){
      idx <- which(dfm$.pred_survival <= 0.5)[1]
      if (!is.na(idx)) dfm$.eval_time[idx] else NA_real_
    })
    
    list(risk = risk_wide, median = median_vec, surv_grid = surv_grid)
  })
  
  output$risk_table <- renderTable({ req(preds()); preds()$risk }, digits = 3)
  
  output$median_table <- renderTable({
    req(preds())
    med <- preds()$median
    label <- ifelse(is.na(med[1]),
                    paste0("Not reached by ", max(grid_times), " mo"),
                    sprintf("%.1f", med[1]))
    tibble(`Median time (mo)` = label)
  })
  
  # Plot transplantability curve (1 - S) for first row
  output$surv_plot <- renderPlot({
    req(preds())
    sg <- preds()$surv_grid
    
    good_idx <- which(purrr::map_lgl(sg$.pred, ~ is.data.frame(.x) && nrow(.x) > 0))[1]
    validate(need(length(good_idx) == 1, "No curve available to plot."))
    
    dfc <- sg$.pred[[good_idx]]
    validate(need(all(c(".eval_time",".pred_survival") %in% names(dfc)),
                  "Prediction object missing required columns."))
    
    x <- suppressWarnings(as.numeric(dfc$.eval_time))
    y <- suppressWarnings(as.numeric(dfc$.pred_survival))
    validate(need(length(x) == length(y) && length(x) > 0, "Invalid curve length."))
    validate(need(all(is.finite(x)) && all(is.finite(y)), "Curve contains non-finite values."))
    
    y_tx <- (1 - y) * 100
    plot(x, y_tx, type = "l",
         xlab = "Time (months)", ylab = "Tx probability (1 - S(t)) [%]",
         main = "Predicted transplantability (first row)", ylim = c(0, 100))
    abline(h = 50, lty = 2)
  }, res = 96)
}

shinyApp(ui, server)


